$date
	Tue Sep 30 22:10:08 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test $end
$var wire 8 ! regA_out [7:0] $end
$var wire 8 " regB_out [7:0] $end
$var reg 1 # add_test_failed $end
$var reg 1 $ clk $end
$var reg 1 % mov_test_failed $end
$var reg 1 & shl_test_failed $end
$scope module Comp $end
$var wire 1 $ clk $end
$var wire 8 ' one [7:0] $end
$var wire 1 ( reset $end
$var wire 8 ) zero [7:0] $end
$var wire 4 * status_flags [3:0] $end
$var wire 8 + regB_out [7:0] $end
$var wire 8 , regA_out [7:0] $end
$var wire 8 - pc_addr [7:0] $end
$var wire 7 . opcode [6:0] $end
$var wire 8 / muxData_out [7:0] $end
$var wire 8 0 muxB_out [7:0] $end
$var wire 8 1 muxA_out [7:0] $end
$var wire 8 2 literal [7:0] $end
$var wire 15 3 instruction [14:0] $end
$var wire 8 4 data_mem_out [7:0] $end
$var wire 1 5 ctrl_S_D $end
$var wire 2 6 ctrl_S_B [1:0] $end
$var wire 2 7 ctrl_S_A [1:0] $end
$var wire 1 8 ctrl_L_PC $end
$var wire 1 9 ctrl_L_B $end
$var wire 1 : ctrl_L_A $end
$var wire 1 ; ctrl_D_W $end
$var wire 3 < ctrl_ALU_Sel [2:0] $end
$var wire 8 = alu_out [7:0] $end
$var wire 1 > alu_Z $end
$var wire 1 ? alu_V $end
$var wire 1 @ alu_N $end
$var wire 1 A alu_C $end
$scope module ALU $end
$var wire 8 B B [7:0] $end
$var wire 3 C ALU_Sel [2:0] $end
$var wire 8 D A [7:0] $end
$var reg 1 A C $end
$var reg 1 @ N $end
$var reg 8 E Result [7:0] $end
$var reg 1 ? V $end
$var reg 1 > Z $end
$upscope $end
$scope module ControlUnit $end
$var wire 7 F opcode [6:0] $end
$var wire 4 G status_flags [3:0] $end
$var wire 1 H Z $end
$var wire 1 I V $end
$var wire 1 J N $end
$var wire 1 K C $end
$var reg 3 L ALU_Sel [2:0] $end
$var reg 1 ; D_W $end
$var reg 1 : L_A $end
$var reg 1 9 L_B $end
$var reg 1 8 L_PC $end
$var reg 2 M S_A [1:0] $end
$var reg 2 N S_B [1:0] $end
$var reg 1 5 S_D $end
$upscope $end
$scope module DataMemory $end
$var wire 1 $ clk $end
$var wire 8 O data_in [7:0] $end
$var wire 1 ( reset $end
$var wire 1 ; write_enable $end
$var wire 8 P address [7:0] $end
$var reg 8 Q data_out [7:0] $end
$upscope $end
$scope module InstructionMemory $end
$var wire 15 R out [14:0] $end
$var wire 8 S address [7:0] $end
$upscope $end
$scope module MuxA $end
$var wire 8 T one [7:0] $end
$var wire 2 U sel [1:0] $end
$var wire 8 V zero [7:0] $end
$var wire 8 W regB [7:0] $end
$var wire 8 X regA [7:0] $end
$var reg 8 Y out [7:0] $end
$upscope $end
$scope module MuxB $end
$var wire 8 Z datam [7:0] $end
$var wire 8 [ lit [7:0] $end
$var wire 2 \ sel [1:0] $end
$var wire 8 ] zero [7:0] $end
$var wire 8 ^ regB [7:0] $end
$var reg 8 _ out [7:0] $end
$upscope $end
$scope module MuxData $end
$var wire 8 ` lit [7:0] $end
$var wire 1 5 sel $end
$var wire 8 a regB [7:0] $end
$var reg 8 b out [7:0] $end
$upscope $end
$scope module ProgramCounter $end
$var wire 1 $ clk $end
$var wire 1 8 load $end
$var wire 8 c new_addr [7:0] $end
$var wire 1 ( reset $end
$var reg 8 d addr [7:0] $end
$upscope $end
$scope module Status $end
$var wire 1 $ clk $end
$var wire 4 e flags_in [3:0] $end
$var wire 1 ( reset $end
$var reg 4 f flags_out [3:0] $end
$upscope $end
$scope module regA $end
$var wire 1 $ clk $end
$var wire 8 g data_in [7:0] $end
$var wire 1 : load $end
$var wire 1 ( reset $end
$var reg 8 h out [7:0] $end
$upscope $end
$scope module regB $end
$var wire 1 $ clk $end
$var wire 8 i data_in [7:0] $end
$var wire 1 9 load $end
$var wire 1 ( reset $end
$var reg 8 j out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 j
b101010 i
b0 h
b101010 g
b0 f
b0 e
b0 d
b101010 c
b101010 b
b0 a
b101010 `
b101010 _
b0 ^
b0 ]
b10 \
b101010 [
bx Z
b0 Y
b0 X
b0 W
b0 V
b10 U
b1 T
b0 S
b1000101010 R
bx Q
b101010 P
b101010 O
b10 N
b10 M
b0 L
0K
0J
0I
0H
b0 G
b10 F
b101010 E
b0 D
b0 C
b101010 B
0A
0@
0?
0>
b101010 =
b0 <
0;
1:
09
08
b10 7
b10 6
05
bx 4
b1000101010 3
b101010 2
b0 1
b101010 0
b101010 /
b10 .
b0 -
b0 ,
b0 +
b0 *
b0 )
0(
b1 '
0&
0%
0$
0#
b0 "
b0 !
$end
#1
b1111011 =
b1111011 E
b1111011 O
b1111011 g
b1111011 i
b1111011 0
b1111011 B
b1111011 _
b1111011 /
b1111011 P
b1111011 b
19
b10 6
b10 N
b10 \
b10 7
b10 M
b10 U
0:
b1111011 2
b1111011 [
b1111011 `
b1111011 c
b11 .
b11 F
b1101111011 3
b1101111011 R
b1 -
b1 S
b1 d
b101010 !
b101010 ,
b101010 X
b101010 h
1$
#2
0$
#3
b10 =
b10 E
b10 O
b10 g
b10 i
1:
b10 6
b10 N
b10 \
b10 7
b10 M
b10 U
09
b10 0
b10 B
b10 _
b10 /
b10 P
b10 b
b10 2
b10 [
b10 `
b10 c
b10 .
b10 F
b1111011 "
b1111011 +
b1111011 W
b1111011 ^
b1111011 a
b1111011 j
b1000000010 3
b1000000010 R
b10 -
b10 S
b10 d
1$
#4
0$
#5
b11 =
b11 E
b11 O
b11 g
b11 i
b11 0
b11 B
b11 _
b11 /
b11 P
b11 b
19
b10 6
b10 N
b10 \
b10 7
b10 M
b10 U
0:
b11 2
b11 [
b11 `
b11 c
b11 .
b11 F
b1100000011 3
b1100000011 R
b11 -
b11 S
b11 d
b10 !
b10 ,
b10 X
b10 h
1$
#6
0$
#7
b10 1
b10 D
b10 Y
b0 e
0>
b101 =
b101 E
b101 O
b101 g
b101 i
1:
b0 6
b0 N
b0 \
b0 7
b0 M
b0 U
09
b11 0
b11 B
b11 _
b0 /
b0 P
b0 b
b0 2
b0 [
b0 `
b0 c
b100 .
b100 F
b11 "
b11 +
b11 W
b11 ^
b11 a
b11 j
b10000000000 3
b10000000000 R
b100 -
b100 S
b100 d
1$
#8
0$
#9
b101 0
b101 B
b101 _
b101 /
b101 P
b101 b
b10 6
b10 N
b10 \
b10 7
b10 M
b10 U
1:
b101 =
b101 E
b101 O
b101 g
b101 i
b101 2
b101 [
b101 `
b101 c
b10 .
b10 F
b0 1
b0 D
b0 Y
b1000000101 3
b1000000101 R
b101 -
b101 S
b101 d
b101 !
b101 ,
b101 X
b101 h
1$
#10
0$
#11
b1010 =
b1010 E
b1010 O
b1010 g
b1010 i
b101 1
b101 D
b101 Y
b11 0
b11 B
b11 _
b0 /
b0 P
b0 b
b110 <
b110 C
b110 L
b0 6
b0 N
b0 \
b0 7
b0 M
b0 U
1:
b0 2
b0 [
b0 `
b0 c
b11100 .
b11100 F
b1110000000000 3
b1110000000000 R
b110 -
b110 S
b110 d
1$
#12
0$
#13
bx /
bx P
bx b
b0 <
b0 C
b0 L
0:
b1101 =
b1101 E
b1101 O
b1101 g
b1101 i
bx 2
bx [
bx `
bx c
bx .
bx F
b1010 1
b1010 D
b1010 Y
bx 3
bx R
b111 -
b111 S
b111 d
b1010 !
b1010 ,
b1010 X
b1010 h
1$
#14
0$
#15
b1000 -
b1000 S
b1000 d
1$
#16
0$
#17
b1001 -
b1001 S
b1001 d
1$
